{"componentChunkName":"component---node-modules-gatsby-theme-ocular-src-react-templates-search-jsx","path":"/search","result":{"pageContext":{"data":[{"excerpt":"Bindings As a C library, bindings can be made to call H3 functions from different programming languages. This page lists different bindings…","rawMarkdownBody":"# Bindings\n\nAs a C library, bindings can be made to call H3 functions from different programming languages. This page lists different bindings currently available. Contributions to this list are welcome, please feel free to open a [pull request](https://github.com/uber/h3/tree/master/docs/community/bindings.md).\n\n## BigQuery\n\n- [cartodb/bigquery-jslibs](https://github.com/CartoDB/bigquery-jslibs)\n\n## C&#35;\n\n- [entrepreneur-interet-general/h3.standard](https://github.com/entrepreneur-interet-general/H3.Standard)\n- [richardvasquez/h3net](https://github.com/RichardVasquez/h3net) - A translation instead of a binding\n\n## ClickHouse\n\n- [Functions for Working with H3 Indexes](https://clickhouse.tech/docs/en/sql-reference/functions/geo/h3/)\n\n## Clojure \n\n- [Factual/geo](https://github.com/Factual/geo)\n\n## ECL\n\n- [hpcc-systems/HPCC-Platform](https://github.com/hpcc-systems/HPCC-Platform/tree/master/plugins/h3)\n\n## Erlang\n\n- [helium/erlang-h3](https://github.com/helium/erlang-h3)\n\n## Go\n\n- [uber/h3-go](https://github.com/uber/h3-go)\n\n## Java\n\n- [uber/h3-java](https://github.com/uber/h3-java)\n\n## JavaScript\n\n- [uber/h3-js](https://github.com/uber/h3-js)\n- [dfellis/h3-node](https://github.com/dfellis/h3-node)\n- [realPrimoh/h3-reactnative](https://github.com/realPrimoh/h3-reactnative)\n\n## Julia\n\n- [wookay/H3.jl](https://github.com/wookay/H3.jl)\n\n## OCaml\n\n- [travisbrady/ocaml-h3](https://github.com/travisbrady/ocaml-h3)\n\n## PHP\n\n- [neatlife/php-h3](https://github.com/neatlife/php-h3)\n\n## PostgreSQL\n\n- [dlr-eoc/pgh3](https://github.com/dlr-eoc/pgh3)\n- [bytesandbrains/h3-pg](https://github.com/bytesandbrains/h3-pg)\n\n## Python\n\n- [uber/h3-py](https://github.com/uber/h3-py)\n\n## R\n\n- [scottmmjackson/h3r](https://github.com/scottmmjackson/h3r)\n- [crazycapivara/h3-r](https://github.com/crazycapivara/h3-r)\n\n## Ruby\n\n- [StuartApp/h3_ruby](https://github.com/StuartApp/h3_ruby)\n\n## Rust\n\n- [rustyconover/libh3-sys](https://github.com/rustyconover/libh3-sys)\n- [rustyconover/libh3](https://github.com/rustyconover/libh3)\n- [nmandery/h3ron](https://github.com/nmandery/h3ron)\n","slug":"docs/community/bindings","title":"Bindings"},{"excerpt":"Libraries Using H3 The following libraries use H3 via one of its bindings. Contributions to this list are welcome, please feel free to open…","rawMarkdownBody":"# Libraries Using H3\n\nThe following libraries use H3 via one of its bindings. Contributions to this list are welcome, please feel free to open a [pull request](https://github.com/uber/h3/tree/master/docs/community/libraries.md).\n\n## JavaScript\n\n- [uber/geojson2H3](https://github.com/uber/geojson2H3) - Conversion utilities between H3 indexes and GeoJSON\n\n## Python\n\n- [nmandery/h3ron/h3ronpy](https://github.com/nmandery/h3ron/tree/master/h3ronpy) - Raster to H3 conversion, smoothing of linked polygons.\n\n## Rust\n\n- [nmandery/h3ron](https://github.com/nmandery/h3ron) - Raster to H3 conversion, smoothing of linked polygons.\n","slug":"docs/community/libraries","title":"Libraries Using H3"},{"excerpt":"Introduction The H3 geospatial indexing system is a multi-precision hexagonal tiling of the sphere indexed with hierarchical linear indexes…","rawMarkdownBody":"# Introduction\n\nThe **H3** geospatial indexing system is a multi-precision hexagonal tiling of the sphere indexed with hierarchical linear indexes. The **H3 Core Library** provides functions for converting between latitude/longitude coordinates and **H3** geospatial indexes. Specifically, the major library entry point functions (defined in `h3api.h`) provide the functionality:\n\n* given a latitude/longitude point, find the index of the containing **H3** cell at a particular resolution\n* given an **H3** index, find the latitude/longitude cell center\n* given an **H3** index, determine the cell boundary in latitude/longitude coordinates\n* and more.\n\nThe **H3 Core Library** is written entirely in *C*. [Bindings for other languages](/docs/community/bindings) are available.\n","slug":"docs","title":"Introduction"},{"excerpt":"Applications Using H3 The following applications use H3. Contributions to this list are welcome, please feel free to open a pull request…","rawMarkdownBody":"# Applications Using H3\n\nThe following applications use H3. Contributions to this list are welcome, please feel free to open a [pull request](https://github.com/uber/h3/tree/master/docs/community/applications.md).\n\n## Visualization\n\n- [kepler.gl](http://kepler.gl/) - An open source geospatial analysis tool\n- [pydeck](https://pydeck.gl/) - High-scale spatial rendering in Python, powered by deck.gl\n","slug":"docs/community/applications","title":"Applications Using H3"},{"excerpt":"Use cases Analysis of data sets of locations, such as locations of cars in a city, may be done by bucketing locations. (Sahr et al., 200…","rawMarkdownBody":"# Use cases\n\nAnalysis of data sets of locations, such as locations of cars in a city, may be done by bucketing locations. ([Sahr et al., 2003](http://webpages.sou.edu/~sahrk/sqspc/pubs/gdggs03.pdf)) There are several options for partitioning an area into buckets, such as manually drawing regions using human knowledge, or to partition the surface using a regular grid.\n\nManually drawn partitions can better incorporate human knowledge, but have a number of drawbacks, such as:\n* The center of a partition may not represent the center of the data points.\n* Edges of partitions may exhibit undesirable boundary effects.\n* Manually defined partitions may require updating if our understanding of the system changes.\n* Manually defining a large number of partitions may be very costly and time consuming.\n\nUsing a regular grid can avoid these drawbacks by providing smooth gradients and the ability to measure differences between cells. One defining characteristic of a grid system is the cell shape. There are only three polygons that tile regularly: the triangle, the square, and the hexagon. Of these, triangles and squares have neighbors with different distances. Triangles have three different distances, and squares have two different distances. For hexagons, all neighbors are equidistant. This property allows for simpler analysis of movement.\n\n| Triangle | Square | Hexagon\n| -------- | ------ | -------\n| <img src=\"/images/neighbors-triangle.png\" style=\"width:400px\"> | <img src=\"/images/neighbors-square.png\" style=\"width:400px\"> | <img src=\"/images/neighbors-hexagon.png\" style=\"width:400px\">\n| Triangles have 12 neighbors | Squares have 8 neighbors | Hexagons have 6 neighbors\n\nIn addition to indexing locations to cells, **H3** provides a number of algorithms operating on indexes.\n\nHexagons have the property of expanding rings of neighbors (`kRing`) approximating circles:\n\n<div align=\"center\">\n  <img src=\"/images/neighbors.png\" style=\"width:400px\"><br>\n  <i>All six neighbors of a hexagon (ring 1)</i>\n</div>\n\nSquares cleanly subdivide into four finer squares. Hexagons do not cleanly subdivide into seven finer hexagons. However, by alternating the orientation of grids a subdivision into seven cells (referred to as *aperture 7*) can be approximated. This makes it possible to truncate the precision (within a fixed margin of error) of an **H3** index using a few bitwise operations (`h3ToParent`). It is also possible to determine all the children of a parent **H3** index (`h3ToChildren`). Approximate containment only applies when truncating the precision of an **H3** index. The borders of hexagons indexed at a specific resolution are not approximate.\n\n<div align=\"center\">\n  <img src=\"/images/parent-child.png\" style=\"width:400px\"><br>\n  <i>A parent hexagon approximately contains seven children</i>\n</div>\n\nHierarchical containment allows for use cases like making contiguous sets of hexagons `compact`. It is then possible to `uncompact` to the same input set of hexagons.\n\n| Uncompact (dense) | Compact (sparse)\n| ----------------- | ----------------\n| <img src=\"/images/ca_uncompact_6_10633.png\" style=\"width:500px\"> | <img src=\"/images/ca_compact_6_901.png\" style=\"width:500px\">\n| California represented by 10633 uncompact hexagons | California represented by 901 compact hexagons\n\n## Comparisons\n\n| System    | Index representation | Cell shape | Projection system\n| --------- | -------------------- | ---------- | -----------------\n| H3        | 64 bit integer       | hexagon    | Icosahedron face centered gnomonic\n| [S2]      | 64 bit integer       | rectangle  | Cube face centered quadratic transform\n| [Geohash] | alphanumeric string  | rectangle  | None, encodes latitude and longitude\n\n[S2]: https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/edit\n[Geohash]: https://en.wikipedia.org/wiki/Geohash\n","slug":"docs/usecases","title":"Use cases"},{"excerpt":"Unix-style Filters for H3 The directory src/apps/filters contains unix-style stdin/stdout filters that perform conversions between integer H…","rawMarkdownBody":"# Unix-style Filters for H3\n\nThe directory `src/apps/filters` contains unix-style stdin/stdout filters that perform conversions between integer **H3** indexes and other useful types. It currently contains the filters listed in the table below. See the header comments in each application source code file for more information.\n\nFilters are experimental and are not part of the semantic version of the H3 library.\n\nAll latitude/longitude coordinates are in decimal degrees. See the [**H3** Index Representations](/docs/core-library/h3indexing) page for information on the integer `H3Index`.\n\n\n| filter           | input     | outputs\n| ---------------- | --------- | -------\n| `geoToH3`        | lat/lon   | `H3Index`\n| `h3ToGeo`        | `H3Index` | cell center point in lat/lon\n| `h3ToGeoBoundary`| `H3Index` | cell boundary in lat/lon\n| `h3ToComponents` | `H3Index` | components\n| `kRing`          | `H3Index` | surrounding `H3Index`\n| `hexRange`       | `H3Index` | surrounding `H3Index`, in order\n\nUnix Command Line Examples\n---\n\n* find the index for coordinates at resolution 5\n\n     `geoToH3 --resolution 5 --latitude 40.689167 --longitude -74.044444`\n\n* output the cell center point for `H3Index` 845ad1bffffffff\n\n     `h3ToGeo --index 845ad1bffffffff`\n\n* output the cell boundary for `H3Index` 845ad1bffffffff\n\n     `h3ToGeoBoundary --index 845ad1bffffffff`\n\n* find the components for the `H3Index` 845ad1bffffffff\n\n     `h3ToComponents --index 845ad1bffffffff`\n\n* output all indexes within distance 1 of the `H3Index` 845ad1bffffffff\n\n     `kRing -k 1 --origin 845ad1bffffffff`\n\n* output all hexagon indexes within distance 2 of the `H3Index` 845ad1bffffffff\n\n     `hexRange -k 2 --origin 845ad1bffffffff`\n\nNote that the filters `h3ToGeo` and `h3ToGeoBoundary` take optional arguments that allow them to generate `kml` output. See the header comments in the corresponding source code files for details.\n","slug":"docs/core-library/filters","title":"Unix-style Filters for H3"},{"excerpt":"Coordinate systems The H3 Core Library uses the following coordinate systems internally. IJK Coordinates Discrete hexagon planar grid…","rawMarkdownBody":"# Coordinate systems\n\nThe **H3 Core Library** uses the following coordinate systems internally.\n\nIJK Coordinates\n---\n\nDiscrete hexagon planar grid systems naturally have 3 coordinate axes spaced 120&deg; apart. We refer to such a system as an *ijk coordinate system*, for the three coordinate axes *i*, *j*, and *k*. A single *ijk* coordinate triplet is represented in the **H3 Core Library** using the structure type `CoordIJK`.\n\nUsing an *ijk* coordinate system to address hexagon grid cells provides multiple valid addresses for each cell. *Normalizing* an *ijk* address (function `_ijkNormalize`) creates a unique address consisting of the minimal positive *ijk* components; this always results in at most two non-zero components.\n\n<div align=\"center\">\n  <img height=\"300\" src=\"/images/ijkp.png\" />\n</div>\n\nFaceIJK Coordinates\n---\n\nThe **H3 Core Library** centers an *ijk* coordinate system on each face of the icosahedron; the combination of a face number and *ijk* coordinates on that face's coordinate system is represented using the structure type `FaceIJK`.\n\nEach grid resolution is rotated ~19.1&deg; relative to the next coarser resolution. The rotation alternates between counterclockwise and clockwise at each successive resolution, so that each resolution will have one of two possible orientations: *Class II* or *Class III* (using a terminology coined by R. Buckminster Fuller). The base cells, which make up resolution 0, are *Class II*.\n\n<div align=\"center\">\n  <img height=\"300\" src=\"/images/classII.III.png\" />\n</div>\n\nHex2d Coordinates\n---\n\nA *Hex2d* coordinate system is a cartesian coordinate system associated with a specific *ijk* coordinate system, where:\n\n* the origin of the *Hex2d* system is centered on the origin cell of the *ijk* system, \n* the positive *x*-axis of the *Hex2d* system is aligned with the *i*-axis of the *ijk* system, and\n* 1.0 unit distance in the *Hex2d* system is the distance between adjacent cell centers in the *ijk* coordinate system.\n\n*Hex2d* coordinates are represented using the structure type `Vec2d`.\n\nLocal IJ Coordinates\n---\n\nAlgorithms working with hexagons may want to refer to grid coordinates that are not interrupted by base cells or faces. These coordinates have 2 coordinate axes spaced 120&deg; apart, with the coordinates anchored by an *origin* H3 index.\n\n* local coordinates are only comparable when they have the same *origin* index.\n* local coordinates are only valid near the *origin*. Pratically, this is within the same base cell or a neighboring base cell, except for pentagons.\n* the coordinate space may have deleted or warped regions due to pentagon distortion.\n* there may be multiple coordinates for the same index, with the same *origin*.\n* the *origin* may not be at `(0, 0)` in the local coordinate space.\n\n*Local IJ* coordinates are represented using the structure type `CoordIJ` and an associated *origin* `H3Index`.\n","slug":"docs/core-library/coordsystems","title":"Coordinate systems"},{"excerpt":"Conversion from latitude/longitude to containing H3 cell index This operation is performed by function geoToH3. See the comments in the…","rawMarkdownBody":"# Conversion from latitude/longitude to containing H3 cell index\n\nThis operation is performed by function `geoToH3`. See the comments in the function for more detail.\n\nThe conversion is performed as a series of coordinate system conversions described below. See the page [Coordinate Systems used by the **H3 Core Library**](/docs/core-library/coordsystems) for more information on each of these coordinate systems.\n\n1. The input latitude/longitude coordinate is first converted into the containing icosahedron face and a *Hex2d* coordinate on that face using function `_geoToHex2d`, which determines the correct face and then performs a face-centered gnomonic projection into face-centered polar coordinates. These polar coordinates are then scaled appropriately to a *Hex2d* coordinate on the input grid resolution *r*.\n2. The *Hex2d* coordinate is converted into resolution *r* normalized *ijk* coordinates using function `_hex2dToCoordIJK`.\n3. The face and face-centered *ijk* coordinates are then converted into an `H3Index` representation using the following steps:\n\n   * the **H3** index digits are calculated from resolution *r* up to 0, adjusting the *ijk* coordinates at each successively coarser resolution.\n   * when resolution 0 is reached, if the remaining *ijk* coordinates are (0,0,0) then the base cell centered on the face is chosen for the index\n   * if the remaining resolution 0 *ijk* coordinates are not (0,0,0), then a lookup operation is performed to find the appropriate base cell and the required rotation (if any) to orient the cell in that base cell's coordinate system. The index is then translated and rotated into the coordinate system centered on the new base cell.\n","slug":"docs/core-library/geoToH3desc","title":"Conversion from latitude/longitude to containing H3 cell index"},{"excerpt":"Generate the cell boundary in latitude/longitude coordinates of an H3Index cell This operation is performed by function h3ToGeoBoundary. See…","rawMarkdownBody":"# Generate the cell boundary in latitude/longitude coordinates of an H3Index cell\n\nThis operation is performed by function `h3ToGeoBoundary`. See the comments in the function source code for more detail.\n\nThe conversion is performed as a series of coordinate system conversions described below. See the page [Coordinate Systems used by the **H3 Core Library**](/docs/core-library/coordsystems) for more information on each of these coordinate systems.\n\n* We note that the cell vertices are the center points of cells in an aperture 3 grid one resolution finer than the cell resolution, which we term a *substrate* grid. We precalculate the substrate *ijk* coordinates of a cell with *ijk* coordinates (0,0,0), adding additional aperture 3 and aperture 7 (if required, by Class III cell grid) substrate grid resolutions as required to transform the vertex coordinates into a Class II substrate grid.\n\n<div align=\"center\">\n  <img height=\"300\" src=\"/images/substrate3.png\" />\n</div>\n\n* The function `_faceIjkToGeoBoundary` calculates the *ijk* coordinates of the cell center point in the appropriate substrate grid (determined in the last step), and each of the substrate vertices is translated using the cell center point *ijk*. Each vertex *ijk* is then transformed onto the appropriate face and *Hex2d* coordinate system using the approach taken in [finding a cell center point](/docs/core-library/h3ToGeoDesc). If adjacent vertices lie on different icosahedron faces a point is introduced at the intersection of the cell edge and icosahedron face edge.\n* The *Hex2d* coordinates are then converted to latitude/longitude using `_hex2dToGeo`.\n","slug":"docs/core-library/h3ToGeoBoundaryDesc","title":"Generate the cell boundary in latitude/longitude coordinates of an H3Index cell"},{"excerpt":"Determine the latitude/longitude coordinates of the center point of an H3Index cell This operation is performed by function h3ToGeo. See the…","rawMarkdownBody":"# Determine the latitude/longitude coordinates of the center point of an H3Index cell\n\nThis operation is performed by function `h3ToGeo`. See the comments in the function source code for more detail.\n\nThe conversion is performed as a series of coordinate system conversions described below. See the page [Coordinate Systems used by the **H3 Core Library**](/docs/core-library/coordsystems) for more information on each of these coordinate systems.\n\n*  The function `_h3ToFaceIjk` then converts the **H3** index to the appropriate icosahedron face number and normalized *ijk* coordinate's on that face's coordinate system as follows:\n   * We start by assuming that the cell center point falls on the same icosahedron face as its base cell.\n   * It is possible that the the cell center point lies on an adjacent face (termed an *overage* in the code), in which case we would need to use a projection centered on that adjacent face instead. We recall that normalized *ijk* coordinates have at most two non-zero components, and that in a face-centered Class II system the sum of those components is a resolution-specific constant value for cells that lie on the edge of that icosahedral face.\n     We determine whether an overage exists by taking the sum of the *ijk* components, and if there is an overage the positive *ijk* components indicate which adjacent face the cell center lies on. A lookup operation is then performed to find the appropriate rotation and translation to transform the *ijk* coordinates into the adjacent face-centered *ijk* system.\n\n<div align=\"center\">\n  <img height=\"300\" src=\"/images/triEdge.png\" />\n</div>\n\n* The face-centered *ijk* coordinates are then converted into corresponding *Hex2d* coordinates using the function `_ijkToHex2d`.\n* The function `_hex2dToGeo` takes the *Hex2d* coordinates and scales them into face-centered gnomonic coordinates, and then performs an inverse gnomonic projection to get the latitude/longitude coordinates.\n","slug":"docs/core-library/h3ToGeoDesc","title":"Determine the latitude/longitude coordinates of the center point of an H3Index cell"},{"excerpt":"Overview of the H3 Geospatial Indexing System The H3 geospatial indexing system is a discrete global grid system (see Sahr et al., 200…","rawMarkdownBody":"# Overview of the H3 Geospatial Indexing System\n\nThe **H3** geospatial indexing system is a discrete global grid system (see [Sahr et al., 2003](http://webpages.sou.edu/~sahrk/sqspc/pubs/gdggs03.pdf)) consisting of a multi-precision hexagonal tiling of the sphere with hierarchical indexes. The hexagonal grid system is created on the planar faces of a sphere-circumscribed icosahedron, and the grid cells are then projected to the surface of the sphere using an inverse face-centered polyhedral gnomonic projection.\n\nThe icosahedron is fixed relative to the sphere using a *Dymaxion* orientation (due to R. Buckminster Fuller). This is the only known orientation of a spherical icosahedron that places all 12 icosahedron vertices in the ocean.\n\nThe **H3** grid is constructed on the icosahedron by recursively creating increasingly higher precision hexagon grids until the desired resolution is achieved. Note that it is impossible to tile the sphere/icosahedron completely with hexagons; each resolution of an icosahedral hexagon grid must contain exactly 12 pentagons at every resolution, with one pentagon centered on each of the icosahedron vertices.\n\nThe first **H3** resolution (resolution 0) consists of 122 cells (110 hexagons and 12 icosahedron vertex-centered pentagons), referred to as the *base cells*. These were chosen to capture as much of the symmetry of the spherical icosahedron as possible. These base cells are assigned numbers from 0 to 121 based on the latitude of their center points; base cell 0 has the northern most center point, while base cell 121 has the southern most center point.\n\nEach subsequent resolution beyond resolution 0 is created using an aperture 7 resolution spacing (aperture refers to the number of cells in the next finer resolution grid for each cell); as resolution increases the unit length is scaled by $\\sqrt{7}$ and each hexagon has $1/7th$ the area of a hexagon at the next coarser resolution (as measured on the icosahedron). **H3** provides 15 finer grid resolutions in addition to the resolution 0 base cells. The finest resolution, resolution 15, has cells with an area of less than $1 m^2$. A table detailing the average cell area for each H3 resolution is available [here](/docs/core-library/restable).\n\n*Note:* you can create KML files to visualize the **H3** grids by running the `kml` make target. It will place the files in the `KML` output sub-directory.\n","slug":"docs/core-library/overview","title":"Overview of the H3 Geospatial Indexing System"},{"excerpt":"Table of Cell Areas for H3 Resolutions H3 Resolution Average Hexagon Area (km2) Average Hexagon Edge Length (km) Number of unique indexes…","rawMarkdownBody":"# Table of Cell Areas for H3 Resolutions\n\n| H3 Resolution | Average Hexagon Area (km<sup>2</sup>) | Average Hexagon Edge Length (km) | Number of unique indexes\n| ------------- | ------------------------------------: | -------------------------------: | -----------------------:\n| 0             | 4,250,546.8477000                     | 1,107.712591000                  |                 122\n| 1             |   607,220.9782429                     |   418.676005500                  |                 842\n| 2             |    86,745.8540347                     |   158.244655800                  |               5,882\n| 3             |    12,392.2648621                     |    59.810857940                  |              41,162\n| 4             |     1,770.3235517                     |    22.606379400                  |             288,122\n| 5             |       252.9033645                     |     8.544408276                  |           2,016,842\n| 6             |        36.1290521                     |     3.229482772                  |          14,117,882\n| 7             |         5.1612932                     |     1.220629759                  |          98,825,162\n| 8             |         0.7373276                     |     0.461354684                  |         691,776,122\n| 9             |         0.1053325                     |     0.174375668                  |       4,842,432,842\n| 10            |         0.0150475                     |     0.065907807                  |      33,897,029,882\n| 11            |         0.0021496                     |     0.024910561                  |     237,279,209,162\n| 12            |         0.0003071                     |     0.009415526                  |   1,660,954,464,122\n| 13            |         0.0000439                     |     0.003559893                  |  11,626,681,248,842\n| 14            |         0.0000063                     |     0.001348575                  |  81,386,768,741,882\n| 15            |         0.0000009                     |     0.000509713                  | 569,707,381,193,162\n","slug":"docs/core-library/restable","title":"Table of Cell Areas for H3 Resolutions"},{"excerpt":"H3 Index Representations Introduction The H3 system assigns a unique hierarchical index to each cell. The H3 index of a resolution r cell…","rawMarkdownBody":"# H3 Index Representations\n\n## Introduction\n\nThe **H3** system assigns a unique hierarchical index to each cell. The **H3** index of a resolution *r* cell begins with the appropriate resolution 0 base cell number. This is followed by a sequence of *r* digits 0-6, where each *i*<sup>th</sup> digit *d*<sub>i</sub> specifies one of the 7 cells centered on the cell indicated by the coarser resolution digits *d*<sub>1</sub> through *d*<sub>i-1</sub>. A local hexagon coordinate system is assigned to each of the resolution 0 base cells and is used to orient all hierarchical indexing child cells of that base cell. The assignment of digits 0-6 at each resolution uses a *Central Place Indexing* arrangement (see [Sahr, 2014](http://webpages.sou.edu/~sahrk/sqspc/pubs/autocarto14.pdf)). In the case of the 12 pentagonal cells the indexing hierarchy produced by sub-digit 1 is removed at all resolutions.\n\nChild hexagons are linearly smaller than their parent hexagons.\n\n<div align=\"center\">\n  <img height=\"300\" src=\"/images/cpidigits.png\" />\n</div>\n\n\n## H3Index Representation\n\nAn **H3Index** is the integer representation of an **H3** index, which may be one of multiple modes to indicate the concept being indexed.\n\n* Mode 0 is reserved and indicates an invalid **H3** index.\n* Mode 1 is an **H3 Cell** (Hexagon/Pentagon) index.\n* Mode 2 is an **H3 Unidirectional Edge** (Cell A -> Cell B) index.\n* Mode 3 is planned to be a bidirectional edge (Cell A <-> Cell B).\n* Mode 4 is an **H3 Vertex** (i.e. a single vertex of an H3 Cell).\n\nThe canonical string representation of an **H3Index** is the hexadecimal representation of the integer, using lowercase letters. The string representation is variable length (no zero padding) and is not prefixed or suffixed.\n\n### Invalid Index\n\nMode 0 contains a special index, `H3_NULL`, which is unique: it is bit-equivalent to `0`.\nThis index indicates, *specifically*, an invalid, missing, or uninitialized **H3** index;\nit is analogous to `NaN` in floating point.\nIt should be used instead of an arbitrary Mode 0 index, due to its uniqueness and easy identifiability.\n\n### H3 Cell Index\n\nAn H3 Cell index (mode 1) represents a cell (hexagon or pentagon) in the H3 grid system at a particular resolution. The components of the H3 Cell index are packed into a 64-bit integer in order, highest bit first, as follows:\n\n* 1 bit reserved and set to 0,\n* 4 bits to indicate the H3 Cell index mode,\n* 3 bits reserved and set to 0,\n* 4 bits to indicate the cell resolution 0-15,\n* 7 bits to indicate the base cell 0-121,\n* 3 bits to indicate each subsequent digit 0-6 from resolution 1 up to the resolution of the cell (45 bits total are reserved for resolutions 1-15)\n\nThe three bits for each unused digit are set to 7.\n\n### H3 Unidirectional Edge Index\n\nAn H3 Undirectional Edge index (mode 2) represents a single directed edge between two cells (an \"origin\" cell and a neighboring \"destination\" cell). The components of the H3 Unidirectional Edge index are packed into a 64-bit integer in order, highest bit first, as follows:\n\n* 1 bit reserved and set to 0,\n* 4 bits to indicate the H3 Unidirectional Edge index mode,\n* 3 bits to indicate the edge (1-6) of the origin cell,\n* Subsequent bits matching the index bits of the origin cell.\n\n### H3 Vertex Index\n\nAn H3 Vertex index (mode 4) represents a single topological vertex in H3 grid system, shared by three cells. Note that this does not include the distortion vertexes occasionally present in a cell's geo boundary. An H3 Vertex is arbitrarily assigned one of the three neighboring cells as its \"owner\", which is used to calculate the canonical index and geo coordinate for the vertex. The components of the H3 Vertex index are packed into a 64-bit integer in order, highest bit first, as follows:\n\n* 1 bit reserved and set to 0,\n* 4 bits to indicate the H3 Vertex index mode,\n* 3 bits to indicate the vertex number (0-5) of vertex on the owner cell,\n* Subsequent bits matching the index bits of the owner cell.\n\n## Bit layout of H3Index\n\nThe layout of an **H3Index** is shown below in table form. The interpretation of the \"Reserved\" field differs depending on the mode of the index.\n\n<table>\n<tr>\n  <th></th>\n  <th>0x0F</th>\n  <th>0x0E</th>\n  <th>0x0D</th>\n  <th>0x0C</th>\n  <th>0x0B</th>\n  <th>0x0A</th>\n  <th>0x09</th>\n  <th>0x08</th>\n  <th>0x07</th>\n  <th>0x06</th>\n  <th>0x05</th>\n  <th>0x04</th>\n  <th>0x03</th>\n  <th>0x02</th>\n  <th>0x01</th>\n  <th>0x00</th>\n</tr>\n<tr>\n  <th>0x30</th>\n  <td>Reserved</td>\n  <td colspan=\"4\">Mode</td>\n  <td colspan=\"3\">Mode-Dependent</td>\n  <td colspan=\"4\">Resolution</td>\n  <td colspan=\"4\">Base cell</td>\n</tr>\n<tr>\n  <th>0x20</th>\n  <td colspan=\"3\">Base cell</td>\n  <td colspan=\"3\">Digit 1</td>\n  <td colspan=\"3\">Digit 2</td>\n  <td colspan=\"3\">Digit 3</td>\n  <td colspan=\"3\">Digit 4</td>\n  <td>Digit 5</td>\n</tr>\n<tr>\n  <th>0x10</th>\n  <td colspan=\"2\">Digit 5</td>\n  <td colspan=\"3\">Digit 6</td>\n  <td colspan=\"3\">Digit 7</td>\n  <td colspan=\"3\">Digit 8</td>\n  <td colspan=\"3\">Digit 9</td>\n  <td colspan=\"2\">Digit 10</td>\n</tr>\n<tr>\n  <th>0x00</th>\n  <td>Digit 10</td>\n  <td colspan=\"3\">Digit 11</td>\n  <td colspan=\"3\">Digit 12</td>\n  <td colspan=\"3\">Digit 13</td>\n  <td colspan=\"3\">Digit 14</td>\n  <td colspan=\"3\">Digit 15</td>\n</tr>\n</table>\n","slug":"docs/core-library/h3indexing","title":"H3 Index Representations"},{"excerpt":"Learning Resources This page lists further learning materials and code walkthroughs for the H3 library and bindings. Contributions to this…","rawMarkdownBody":"# Learning Resources\n\nThis page lists further learning materials and code walkthroughs for the H3 library and bindings. Contributions to this list are welcome, please feel free to open a [pull request](https://github.com/uber/h3/tree/master/docs/community/tutorials.md).\n\n## Community\n\n- [H3 Slack workspace](https://join.slack.com/t/h3-core/shared_invite/zt-g6u5r1hf-W_~uVJmfeiWtMQuBGc1NNg)\n\n## Videos\n\n- [Introduction to H3](https://www.youtube.com/watch?v=wDuKeUkNLkQ) (June 2019)\n- [Engineering an H3-based Geospatial Data Platform at Uber](https://www.youtube.com/watch?v=aCj-YVZ0mlE)\n- [Building City Cores with H3](https://www.youtube.com/watch?v=PutOhe8HVNU)\n- [H3-js: Hexagons in the Browser](https://www.youtube.com/watch?v=BsMIrBHLfLE&list=PLLEUtp5eGr7CNf9Bj3w3i30rzaU8lKZeV&index=16&t=0s)\n- [Hexagon Convolution for Data Smoothing & Forecasting](https://www.youtube.com/watch?v=z3PaGIQTFSE&list=PLLEUtp5eGr7CNf9Bj3w3i30rzaU8lKZeV&index=14&t=0s)\n- [Spatial Intelligence Using Hex](https://www.youtube.com/watch?v=0OlIpNAqokQ&list=PLLEUtp5eGr7CNf9Bj3w3i30rzaU8lKZeV&index=18&t=0s)\n- [Hierarchical Hexagons in Depth](https://www.youtube.com/watch?v=UILoSqvIM2w&list=PLLEUtp5eGr7CNf9Bj3w3i30rzaU8lKZeV&index=15&t=0s)\n- [H3: Tiling the Earth with Hexagons](https://www.youtube.com/watch?v=_-265mfMzl4&list=PLLEUtp5eGr7CNf9Bj3w3i30rzaU8lKZeV&index=22&t=0s) (Introduction to H3, November 2018)\n- [H3: Tiling the Earth with Hexagons](https://www.youtube.com/watch?v=ay2uwtRO3QE) (Introduction to H3, January 2018)\n\n## Java\n\n- [H3 Measurements](https://github.com/isaacbrodsky/h3measurements): Measurements of average cell area, average cell perimeter length, truncation error, and so on.\n\n## JavaScript\n\n- [H3 Tutorials on Observable](https://beta.observablehq.com/collection/@nrabinowitz/h3-tutorial)\n\n## Python\n\n- [Usage (IPython Notebook)](https://github.com/uber/h3-py-notebooks/blob/master/notebooks/usage.ipynb)\n- [Unified Data Layers (IPython Notebook)](https://github.com/uber/h3-py-notebooks/blob/master/notebooks/unified_data_layers.ipynb)\n- [H3 API examples on Urban Analytics(IPython Notebook)](https://github.com/uber/h3-py-notebooks/blob/master/notebooks/urban_analytics.ipynb)\n","slug":"docs/community/tutorials","title":"Learning Resources"},{"excerpt":"How to use H3 The public API of the H3 Core Library is defined in the file h3api.h. The functions defined in h3api.h adhere to Semantic…","rawMarkdownBody":"# How to use H3\n\nThe public API of the **H3 Core Library** is defined in the file h3api.h. The functions defined in h3api.h adhere to [Semantic Versioning](http://semver.org/).\n\nThe **H3** API expects valid input. Behavior of the library may be undefined when given invalid input. Indexes should be validated with `h3IsValid` or `h3UnidirectionalEdgeIsValid` as appropriate.\n\nYou can find an example of using the **H3** library in `examples/index.c`.\n","slug":"docs/core-library/usage","title":"How to use H3"},{"excerpt":"Hierarchical grid functions These functions permit moving between resolutions in the H3 grid system. The functions produce parent (coarser…","rawMarkdownBody":"# Hierarchical grid functions\n\nThese functions permit moving between resolutions in the H3 grid system. The functions produce parent (coarser) or children (finer) cells.\n\n## h3ToParent\n\n```\nH3Index h3ToParent(H3Index h, int parentRes);\n```\n\nReturns the parent (coarser) index containing `h`.\n\n## h3ToChildren\n\n```\nvoid h3ToChildren(H3Index h, int childRes, H3Index *children);\n```\n\nPopulates `children` with the indexes contained by `h` at resolution `childRes`. `children` must be an array of at least size `maxH3ToChildrenSize(h, childRes)`.\n\n### maxH3ToChildrenSize\n\n```\nint maxH3ToChildrenSize(H3Index h, int childRes);\n```\n\nReturns the size of the array needed by `h3ToChildren` for these inputs.\n\n## h3ToCenterChild\n\n```\nH3Index h3ToCenterChild(H3Index h, int childRes);\n```\n\nReturns the center child (finer) index contained by `h` at resolution `childRes`.\n\n## compact\n\n```\nint compact(const H3Index *h3Set, H3Index *compactedSet, const int numHexes);\n```\n\nCompacts the set `h3Set` of indexes as best as possible, into the array `compactedSet`. `compactedSet` must be at least the size of `h3Set` in case the set cannot be compacted.\n\nReturns 0 on success.\n\n## uncompact\n\n```\nint uncompact(const H3Index *compactedSet, const int numHexes, H3Index *h3Set, const int maxHexes, const int res);\n```\n\nUncompacts the set `compactedSet` of indexes to the resolution `res`. `h3Set` must be at least of size `maxUncompactSize(compactedSet, numHexes, res)`.\n\nReturns 0 on success.\n\n### maxUncompactSize\n\n```\nint maxUncompactSize(const H3Index *compactedSet, const int numHexes, const int res)\n```\n\nReturns the size of the array needed by `uncompact`.\n","slug":"docs/api/hierarchy","title":"Hierarchical grid functions"},{"excerpt":"Indexing functions These function are used for finding the H3 index containing coordinates, and for finding the center and boundary of H…","rawMarkdownBody":"# Indexing functions\n\nThese function are used for finding the H3 index containing coordinates, and for finding the center and boundary of H3 indexes.\n\n## geoToH3\n\n```\nH3Index geoToH3(const GeoCoord *g, int res);\n```\n\nIndexes the location at the specified resolution, returning the index of the cell containing the location.\n\nReturns 0 on error.\n\n## h3ToGeo\n\n```\nvoid h3ToGeo(H3Index h3, GeoCoord *g);\n```\n\nFinds the centroid of the index.\n\n## h3ToGeoBoundary\n\n```\nvoid h3ToGeoBoundary(H3Index h3, GeoBoundary *gp);\n```\n\nFinds the boundary of the index.\n","slug":"docs/api/indexing","title":"Indexing functions"},{"excerpt":"Region functions These functions convert H3 indexes to and from polygonal areas. polyfill polyfill takes a given GeoJSON-like data structure…","rawMarkdownBody":"# Region functions\n\nThese functions convert H3 indexes to and from polygonal areas.\n\n## polyfill\n\n```\nvoid polyfill(const GeoPolygon* geoPolygon, int res, H3Index* out);\n```\n\npolyfill takes a given GeoJSON-like data structure and preallocated,\nzeroed memory, and fills it with the hexagons that are contained by\nthe GeoJSON-like data structure.\n\nThe current implementation is very primitive and slow, but correct,\nperforming a point-in-poly operation on every hexagon in a k-ring defined\naround the given geofence.\n\n### maxPolyfillSize\n\n```\nint maxPolyfillSize(const GeoPolygon* geoPolygon, int res);\n```\n\nmaxPolyfillSize returns the number of hexagons to allocate space for when\nperforming a polyfill on the given GeoJSON-like data structure.\n\n## h3SetToLinkedGeo\n\n```\nvoid h3SetToLinkedGeo(const H3Index* h3Set, const int numHexes, LinkedGeoPolygon* out);\n```\n\nCreate a LinkedGeoPolygon describing the outline(s) of a set of  hexagons.\nPolygon outlines will follow GeoJSON MultiPolygon order: Each polygon will\nhave one outer loop, which is first in the list, followed by any holes.\n\nIt is the responsibility of the caller to call destroyLinkedPolygon on the\npopulated linked geo structure, or the memory for that structure will\nnot be freed.\n\nIt is expected that all hexagons in the set have the same resolution and\nthat the set contains no duplicates. Behavior is undefined if duplicates\nor multiple resolutions are present, and the algorithm may produce\nunexpected or invalid output.\n\n### destroyLinkedPolygon\n\n```\nvoid destroyLinkedPolygon(LinkedGeoPolygon* polygon);\n```\n\nFree all allocated memory for a linked geo structure. The caller is\nresponsible for freeing memory allocated to the input polygon struct.\n","slug":"docs/api/regions","title":"Region functions"},{"excerpt":"Index inspection functions These functions provide metadata about an H3 index, such as its resolution or base cell, and provide utilities…","rawMarkdownBody":"# Index inspection functions\n\nThese functions provide metadata about an H3 index, such as its resolution or base cell, and provide utilities for converting into and out of the 64-bit representation of an H3 index.\n\n## h3GetResolution\n\n```\nint h3GetResolution(H3Index h);\n```\n\nReturns the resolution of the index.\n\n## h3GetBaseCell\n\n```\nint h3GetBaseCell(H3Index h);\n```\n\nReturns the base cell number of the index.\n\n## stringToH3\n\n```\nH3Index stringToH3(const char *str);\n```\n\nConverts the string representation to `H3Index` (`uint64_t`) representation.\n\nReturns 0 on error.\n\n## h3ToString\n\n```\nvoid h3ToString(H3Index h, char *str, size_t sz);\n```\n\nConverts the `H3Index` representation of the index to the string representation. `str` must be at least of length 17.\n\n## h3IsValid\n\n```\nint h3IsValid(H3Index h);\n```\n\nReturns non-zero if this is a valid **H3** index.\n\n## h3IsResClassIII\n\n```\nint h3IsResClassIII(H3Index h);\n```\n\nReturns non-zero if this index has a resolution with Class III orientation.\n\n## h3IsPentagon\n\n```\nint h3IsPentagon(H3Index h);\n```\n\nReturns non-zero if this index represents a pentagonal cell.\n\n## h3GetFaces\n\n```\nvoid h3GetFaces(H3Index h, int* out);\n```\n\nFind all icosahedron faces intersected by a given H3 index and places them in the array `out`. `out` must be at least of length `maxFaceCount(h)`.\n\nFaces are represented as integers from 0-19, inclusive. The array is sparse, and empty (no intersection) array values are represented by -1.\n\n### maxFaceCount\n\n```\nint maxFaceCount(H3Index h3);\n```\n\nReturns the maximum number of icosahedron faces the given H3 index may intersect.\n","slug":"docs/api/inspection","title":"Index inspection functions"},{"excerpt":"Miscellaneous H3 functions These functions include descriptions of the H3 grid system. degsToRads Converts degrees to radians. radsToDegs…","rawMarkdownBody":"# Miscellaneous H3 functions\n\nThese functions include descriptions of the H3 grid system.\n\n## degsToRads\n\n```\ndouble degsToRads(double degrees);\n```\n\nConverts degrees to radians.\n\n## radsToDegs\n\n```\ndouble radsToDegs(double radians);\n```\n\nConverts radians to degrees.\n\n## hexAreaKm2\n\n```\ndouble hexAreaKm2(int res);\n```\n\nAverage hexagon area in square kilometers at the given resolution.\n\n## hexAreaM2\n\n```\ndouble hexAreaM2(int res);\n```\n\nAverage hexagon area in square meters at the given resolution.\n\n## cellAreaKm2\n\n```\ndouble cellAreaKm2(H3Index h);\n```\n\nExact area of specific cell in square kilometers.\n\n## cellAreaM2\n\n```\ndouble cellAreaM2(H3Index h);\n```\n\nExact area of specific cell in square meters.\n\n## cellAreaRads2\n\n```\ndouble cellAreaRads2(H3Index h);\n```\n\nExact area of specific cell in square radians.\n\n## edgeLengthKm\n\n```\ndouble edgeLengthKm(int res);\n```\n\nAverage hexagon edge length in kilometers at the given resolution.\n\n## edgeLengthM\n\n```\ndouble edgeLengthM(int res);\n```\n\nAverage hexagon edge length in meters at the given resolution.\n\n\n## exactEdgeLengthKm\n\n```\ndouble exactEdgeLengthKm(H3Index edge);\n```\n\nExact edge length of specific unidirectional edge in kilometers.\n\n## exactEdgeLengthM\n\n```\ndouble exactEdgeLengthM(H3Index edge);\n```\n\nExact edge length of specific unidirectional edge in meters.\n\n## exactEdgeLengthRads\n\n```\ndouble exactEdgeLengthRads(H3Index edge);\n```\n\nExact edge length of specific unidirectional edge in radians.\n\n## numHexagons\n\n```\nint64_t numHexagons(int res);\n```\n\nNumber of unique **H3** indexes at the given resolution.\n\n## getRes0Indexes\n\n```\nvoid getRes0Indexes(H3Index *out);\n```\n\nAll the resolution 0 **H3** indexes.\n`out` must be an array of at least size `res0IndexCount()`.\n\n## res0IndexCount\n\n```\nint res0IndexCount();\n```\n\nNumber of resolution 0 **H3** indexes.\n\n## getPentagonIndexes\n\n```\nvoid getPentagonIndexes(int res, H3Index *out);\n```\n\nAll the pentagon **H3** indexes at the specified resolution.\n`out` must be an array of at least size `pentagonIndexCount()`.\n\n## pentagonIndexCount\n\n```\nint pentagonIndexCount();\n```\n\nNumber of pentagon **H3** indexes per resolution. This is always 12, but provided as a convenience.\n\n## pointDistKm\n\n```\ndouble pointDistKm(const GeoCoord *a, const GeoCoord *b);\n```\n\nGives the \"great circle\" or \"haversine\" distance between pairs of\nGeoCoord points (lat/lng pairs) in kilometers.\n\n## pointDistM\n\n```\ndouble pointDistM(const GeoCoord *a, const GeoCoord *b);\n```\n\nGives the \"great circle\" or \"haversine\" distance between pairs of\nGeoCoord points (lat/lng pairs) in meters.\n\n## pointDistRads\n\n```\ndouble pointDistRads(const GeoCoord *a, const GeoCoord *b);\n```\n\nGives the \"great circle\" or \"haversine\" distance between pairs of\nGeoCoord points (lat/lng pairs) in radians.\n","slug":"docs/api/misc","title":"Miscellaneous H3 functions"},{"excerpt":"Grid traversal functions Grid traversal allows finding cells in the vicinity of an origin cell, and determining how to traverse the grid…","rawMarkdownBody":"# Grid traversal functions\n\nGrid traversal allows finding cells in the vicinity of an origin cell, and determining how to traverse the grid from one cell to another.\n\n## kRing\n\n```\nvoid kRing(H3Index origin, int k, H3Index* out);\n```\n\nk-rings produces indices within k distance of the origin index.\n\nk-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and\nall neighboring indices, and so on.\n\nOutput is placed in the provided array in no particular order. Elements of\nthe output array may be left zero, as can happen when crossing a pentagon.\n\n### maxKringSize\n\n```\nint maxKringSize(int k);\n```\n\nMaximum number of indices that result from the kRing algorithm with the given k.\n\n## kRingDistances\n\n```\nvoid kRingDistances(H3Index origin, int k, H3Index* out, int* distances);\n```\n\nk-rings produces indices within k distance of the origin index.\n\nk-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and\nall neighboring indices, and so on.\n\nOutput is placed in the provided array in no particular order. Elements of\nthe output array may be left zero, as can happen when crossing a pentagon.\n\n## hexRange\n\n```\nint hexRange(H3Index origin, int k, H3Index* out);\n```\n\nhexRange produces indexes within k distance of the origin index.\nOutput behavior is undefined when one of the indexes returned by this\nfunction is a pentagon or is in the pentagon distortion area.\n\nk-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and\nall neighboring indexes, and so on.\n\nOutput is placed in the provided array in order of increasing distance from\nthe origin.\n\nReturns 0 if no pentagonal distortion is encountered.\n \n## hexRangeDistances\n\n```\nint hexRangeDistances(H3Index origin, int k, H3Index* out, int* distances);\n```\n\nhexRange produces indexes within k distance of the origin index.\nOutput behavior is undefined when one of the indexes returned by this\nfunction is a pentagon or is in the pentagon distortion area.\n\nk-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and\nall neighboring indexes, and so on.\n\nOutput is placed in the provided array in order of increasing distance from\nthe origin. The distances in hexagons is placed in the distances array at\nthe same offset.\n \nReturns 0 if no pentagonal distortion is encountered.\n\n## hexRanges\n\n```\nint hexRanges(H3Index* h3Set, int length, int k, H3Index* out);\n```\n\nhexRanges takes an array of input hex IDs and a max k-ring and returns an\narray of hexagon IDs sorted first by the original hex IDs and then by the\nk-ring (0 to max), with no guaranteed sorting within each k-ring group.\n\nReturns 0 if no pentagonal distortion was encountered. Otherwise, output\nis undefined\n\n## hexRing\n\n```\nint hexRing(H3Index origin, int k, H3Index* out);\n```\n\nProduces the hollow hexagonal ring centered at origin with sides of length k.\n \nReturns 0 if no pentagonal distortion was encountered.\n\n## h3Line\n\n```\nint h3Line(H3Index start, H3Index end, H3Index* out);\n```\n\nGiven two H3 indexes, return the line of indexes between them (inclusive).\n\nThis function may fail to find the line between two indexes, for\nexample if they are very far apart. It may also fail when finding\ndistances for indexes on opposite sides of a pentagon.\n\n*Notes:*\n\n * The specific output of this function should not be considered stable\n   across library versions. The only guarantees the library provides are\n   that the line length will be `h3Distance(start, end) + 1` and that\n   every index in the line will be a neighbor of the preceding index.\n\n * Lines are drawn in grid space, and may not correspond exactly to either\n   Cartesian lines or great arcs.\n\n## h3LineSize\n\n```\nint h3LineSize(H3Index start, H3Index end);\n```\n\nNumber of indexes in a line from the start index to the end index,\nto be used for allocating memory. Returns a negative number if the\nline cannot be computed.\n\n## h3Distance\n\n```\nint h3Distance(H3Index origin, H3Index h3);\n```\n\nReturns the distance in grid cells between the two indexes.\n\nReturns a negative number if finding the distance failed. Finding the distance can fail because the two\nindexes are not comparable (different resolutions), too far apart, or are separated by pentagonal\ndistortion. This is the same set of limitations as the local IJ coordinate space functions.\n\n## experimentalH3ToLocalIj\n\n```\nint experimentalH3ToLocalIj(H3Index origin, H3Index h3, CoordIJ *out);\n```\n\nProduces local IJ coordinates for an **H3** index anchored by an origin.\n\nThis function is experimental, and its output is not guaranteed\nto be compatible across different versions of **H3**.\n\n## experimentalLocalIjToH3\n\n```\nint experimentalLocalIjToH3(H3Index origin, const CoordIJ *ij, H3Index *out);\n```\n\nProduces an **H3** index from local IJ coordinates anchored by an origin.\n\nThis function is experimental, and its output is not guaranteed\nto be compatible across different versions of **H3**.\n","slug":"docs/api/traversal","title":"Grid traversal functions"},{"excerpt":"Unidirectional edge functions Unidirectional edges allow encoding the directed edge from one cell to a neighboring cell. h…","rawMarkdownBody":"# Unidirectional edge functions\n\nUnidirectional edges allow encoding the directed edge from one cell to a neighboring cell.\n\n## h3IndexesAreNeighbors\n\n```\nint h3IndexesAreNeighbors(H3Index origin, H3Index destination);\n```\n\nReturns whether or not the provided H3Indexes are neighbors.\n\nReturns 1 if the indexes are neighbors, 0 otherwise.\n\n## getH3UnidirectionalEdge\n\n```\nH3Index getH3UnidirectionalEdge(H3Index origin, H3Index destination);\n```\n\nReturns a unidirectional edge **H3** index based on the provided origin and\ndestination.\n\nReturns 0 on error.\n\n## h3UnidirectionalEdgeIsValid\n\n```\nint h3UnidirectionalEdgeIsValid(H3Index edge);\n```\n\nDetermines if the provided H3Index is a valid unidirectional edge index.\n\nReturns 1 if it is a unidirectional edge H3Index, otherwise 0.\n\n## getOriginH3IndexFromUnidirectionalEdge\n\n```\nH3Index getOriginH3IndexFromUnidirectionalEdge(H3Index edge);\n```\n\nReturns the origin hexagon from the unidirectional edge H3Index.\n\n## getDestinationH3IndexFromUnidirectionalEdge\n\n```\nH3Index getDestinationH3IndexFromUnidirectionalEdge(H3Index edge);\n```\n\nReturns the destination hexagon from the unidirectional edge H3Index.\n\n## getH3IndexesFromUnidirectionalEdge\n\n```\nvoid getH3IndexesFromUnidirectionalEdge(H3Index edge, H3Index* originDestination);\n```\n\nReturns the origin, destination pair of hexagon IDs for the given edge ID, which are placed at `originDestination[0]` and\n`originDestination[1]` respectively.\n\n## getH3UnidirectionalEdgesFromHexagon\n\n```\nvoid getH3UnidirectionalEdgesFromHexagon(H3Index origin, H3Index* edges);\n```\n\nProvides all of the unidirectional edges from the current H3Index. `edges` must be of length 6,\nand the number of undirectional edges placed in the array may be less than 6.\n\n## getH3UnidirectionalEdgeBoundary\n\n```\nvoid getH3UnidirectionalEdgeBoundary(H3Index edge, GeoBoundary* gb);\n```\n\nProvides the coordinates defining the unidirectional edge.\n","slug":"docs/api/uniedge","title":"Unidirectional edge functions"}]}}}